//! Malware Detection Module
//!
//! Detects malicious activity patterns used by eBPF-based malware like:
//! - Symbiote: Uses port hopping and BPF filters to hide traffic
//! - BPFDoor: Uses raw sockets with BPF filters for C2 communication
//!
//! Detection methods:
//! - Monitor bpf() syscalls for unauthorized eBPF program loading
//! - Detect port hopping patterns (rapid connections to multiple high ports)
//! - Analyze DNS traffic for covert channel indicators
//! - Monitor raw socket creation with SO_ATTACH_FILTER

use anyhow::Result;
use tracing::{debug, info, warn};
use std::collections::HashMap;
use std::net::IpAddr;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

use crate::config::{DnsMonitorConfig, EbpfMalwareConfig, PortHoppingConfig};
use crate::database::Database;

/// Shannon entropy calculation for detecting encoded/encrypted data
fn calculate_entropy(data: &[u8]) -> f64 {
    if data.is_empty() {
        return 0.0;
    }

    let mut freq = [0u64; 256];
    for &byte in data {
        freq[byte as usize] += 1;
    }

    let len = data.len() as f64;
    let mut entropy = 0.0;

    for &count in &freq {
        if count > 0 {
            let p = count as f64 / len;
            entropy -= p * p.log2();
        }
    }

    entropy
}

/// Port access record for hopping detection
#[derive(Debug, Clone)]
struct PortAccess {
    ports: Vec<(u16, Instant)>,
    first_seen: Instant,
}

impl PortAccess {
    fn new() -> Self {
        Self {
            ports: Vec::new(),
            first_seen: Instant::now(),
        }
    }

    fn add_port(&mut self, port: u16, window: Duration) {
        let now = Instant::now();
        // Remove old entries outside window
        self.ports
            .retain(|(_, time)| now.duration_since(*time) < window);
        self.ports.push((port, now));
    }

    fn unique_ports(&self, window: Duration) -> usize {
        let now = Instant::now();
        let mut unique: Vec<u16> = self
            .ports
            .iter()
            .filter(|(_, time)| now.duration_since(*time) < window)
            .map(|(port, _)| *port)
            .collect();
        unique.sort();
        unique.dedup();
        unique.len()
    }
}

/// DNS query tracking for rate limiting and entropy analysis
#[derive(Debug, Clone)]
struct DnsQueryTracker {
    queries: Vec<(String, Instant)>,
    high_entropy_count: u32,
    txt_queries: u32,
}

impl DnsQueryTracker {
    fn new() -> Self {
        Self {
            queries: Vec::new(),
            high_entropy_count: 0,
            txt_queries: 0,
        }
    }

    fn add_query(&mut self, domain: &str, window: Duration) {
        let now = Instant::now();
        self.queries
            .retain(|(_, time)| now.duration_since(*time) < window);
        self.queries.push((domain.to_string(), now));
    }

    fn queries_per_minute(&self) -> u32 {
        let now = Instant::now();
        let one_minute = Duration::from_secs(60);
        self.queries
            .iter()
            .filter(|(_, time)| now.duration_since(*time) < one_minute)
            .count() as u32
    }
}

/// eBPF program attachment event
#[derive(Debug, Clone)]
pub struct BpfEvent {
    pub pid: u32,
    pub process_name: String,
    pub program_type: BpfProgramType,
    pub timestamp: Instant,
}

/// BPF program types we care about
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BpfProgramType {
    SocketFilter,
    Kprobe,
    Tracepoint,
    Xdp,
    CgroupSkb,
    RawTracepoint,
    Unknown(u32),
}

impl From<u32> for BpfProgramType {
    fn from(value: u32) -> Self {
        match value {
            1 => BpfProgramType::SocketFilter,
            2 => BpfProgramType::Kprobe,
            5 => BpfProgramType::Tracepoint,
            6 => BpfProgramType::Xdp,
            9 | 10 => BpfProgramType::CgroupSkb,
            17 => BpfProgramType::RawTracepoint,
            _ => BpfProgramType::Unknown(value),
        }
    }
}

/// Detection result
#[derive(Debug, Clone)]
pub struct MalwareDetection {
    pub detection_type: DetectionType,
    pub ip: Option<IpAddr>,
    pub details: String,
    pub severity: Severity,
    pub should_ban: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DetectionType {
    PortHopping,
    DnsCovertChannel,
    DnsHighEntropy,
    DnsRateLimit,
    DnsTxtAbuse,
    UnauthorizedBpf,
    MaliciousPort,
}

impl std::fmt::Display for DetectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DetectionType::PortHopping => write!(f, "port_hopping"),
            DetectionType::DnsCovertChannel => write!(f, "dns_covert_channel"),
            DetectionType::DnsHighEntropy => write!(f, "dns_high_entropy"),
            DetectionType::DnsRateLimit => write!(f, "dns_rate_limit"),
            DetectionType::DnsTxtAbuse => write!(f, "dns_txt_abuse"),
            DetectionType::UnauthorizedBpf => write!(f, "unauthorized_bpf"),
            DetectionType::MaliciousPort => write!(f, "malicious_port"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Severity::Low => write!(f, "low"),
            Severity::Medium => write!(f, "medium"),
            Severity::High => write!(f, "high"),
            Severity::Critical => write!(f, "critical"),
        }
    }
}

/// Malware detection engine
pub struct MalwareDetector {
    ebpf_config: EbpfMalwareConfig,
    dns_config: DnsMonitorConfig,
    port_hopping_config: PortHoppingConfig,
    db: Arc<Database>,

    // Port hopping tracking
    port_access: RwLock<HashMap<IpAddr, PortAccess>>,

    // DNS tracking
    dns_trackers: RwLock<HashMap<IpAddr, DnsQueryTracker>>,

    // BPF event tracking
    bpf_events: RwLock<Vec<BpfEvent>>,
}

impl MalwareDetector {
    pub fn new(
        ebpf_config: EbpfMalwareConfig,
        dns_config: DnsMonitorConfig,
        port_hopping_config: PortHoppingConfig,
        db: Arc<Database>,
    ) -> Self {
        Self {
            ebpf_config,
            dns_config,
            port_hopping_config,
            db,
            port_access: RwLock::new(HashMap::new()),
            dns_trackers: RwLock::new(HashMap::new()),
            bpf_events: RwLock::new(Vec::new()),
        }
    }

    /// Check if any detection features are enabled
    pub fn is_enabled(&self) -> bool {
        self.ebpf_config.enabled || self.dns_config.enabled || self.port_hopping_config.enabled
    }

    /// Record a port access and check for hopping patterns
    pub async fn record_port_access(&self, ip: IpAddr, port: u16) -> Option<MalwareDetection> {
        if !self.port_hopping_config.enabled {
            return None;
        }

        // Ignore low ports (well-known services)
        if port < self.port_hopping_config.min_port {
            return None;
        }

        // Check for known malicious Symbiote ports
        if self.ebpf_config.known_malicious_ports.contains(&port) {
            return Some(MalwareDetection {
                detection_type: DetectionType::MaliciousPort,
                ip: Some(ip),
                details: format!(
                    "Connection to known malicious Symbiote port {} from {}",
                    port, ip
                ),
                severity: Severity::Critical,
                should_ban: true,
            });
        }

        let window = Duration::from_secs(self.port_hopping_config.window_secs);

        let mut access_map = self.port_access.write().await;
        let entry = access_map.entry(ip).or_insert_with(PortAccess::new);
        entry.add_port(port, window);

        let unique_count = entry.unique_ports(window);

        if unique_count >= self.port_hopping_config.threshold as usize {
            info!(
                "Port hopping detected from {}: {} unique ports in {:?}",
                ip, unique_count, window
            );
            return Some(MalwareDetection {
                detection_type: DetectionType::PortHopping,
                ip: Some(ip),
                details: format!(
                    "Rapid port hopping: {} unique high ports in {} seconds (threshold: {})",
                    unique_count,
                    self.port_hopping_config.window_secs,
                    self.port_hopping_config.threshold
                ),
                severity: Severity::High,
                should_ban: true,
            });
        }

        None
    }

    /// Analyze a DNS query for covert channel indicators
    pub async fn analyze_dns_query(
        &self,
        ip: IpAddr,
        query_name: &str,
        query_type: u16,
        response_size: Option<usize>,
    ) -> Option<MalwareDetection> {
        if !self.dns_config.enabled {
            return None;
        }

        let window = Duration::from_secs(60);

        // Update tracker
        let mut trackers = self.dns_trackers.write().await;
        let tracker = trackers.entry(ip).or_insert_with(DnsQueryTracker::new);
        tracker.add_query(query_name, window);

        // Check rate limit
        if tracker.queries_per_minute() > self.dns_config.max_queries_per_minute {
            return Some(MalwareDetection {
                detection_type: DetectionType::DnsRateLimit,
                ip: Some(ip),
                details: format!(
                    "DNS rate limit exceeded: {} queries/min from {} (limit: {})",
                    tracker.queries_per_minute(),
                    ip,
                    self.dns_config.max_queries_per_minute
                ),
                severity: Severity::Medium,
                should_ban: false, // Just log initially
            });
        }

        // Check for unusually long query names (potential tunneling)
        if query_name.len() > self.dns_config.max_query_length {
            let entropy = calculate_entropy(query_name.as_bytes());
            if entropy > self.dns_config.entropy_threshold {
                tracker.high_entropy_count += 1;

                if tracker.high_entropy_count > 5 {
                    return Some(MalwareDetection {
                        detection_type: DetectionType::DnsCovertChannel,
                        ip: Some(ip),
                        details: format!(
                            "Potential DNS covert channel: {} high-entropy queries from {} (entropy: {:.2})",
                            tracker.high_entropy_count, ip, entropy
                        ),
                        severity: Severity::High,
                        should_ban: true,
                    });
                }

                return Some(MalwareDetection {
                    detection_type: DetectionType::DnsHighEntropy,
                    ip: Some(ip),
                    details: format!(
                        "High entropy DNS query from {}: '{}' (entropy: {:.2}, length: {})",
                        ip,
                        query_name,
                        entropy,
                        query_name.len()
                    ),
                    severity: Severity::Low,
                    should_ban: false,
                });
            }
        }

        // Check for TXT record abuse (query_type 16 = TXT)
        if query_type == 16 && self.dns_config.detect_txt_abuse {
            tracker.txt_queries += 1;

            if let Some(size) = response_size {
                if size > self.dns_config.max_txt_response_size {
                    return Some(MalwareDetection {
                        detection_type: DetectionType::DnsTxtAbuse,
                        ip: Some(ip),
                        details: format!(
                            "Oversized TXT response: {} bytes for {} from {} (limit: {})",
                            size, query_name, ip, self.dns_config.max_txt_response_size
                        ),
                        severity: Severity::Medium,
                        should_ban: tracker.txt_queries > 10,
                    });
                }
            }

            if tracker.txt_queries > 20 {
                return Some(MalwareDetection {
                    detection_type: DetectionType::DnsTxtAbuse,
                    ip: Some(ip),
                    details: format!(
                        "Excessive TXT queries from {}: {} queries",
                        ip, tracker.txt_queries
                    ),
                    severity: Severity::Medium,
                    should_ban: true,
                });
            }
        }

        None
    }

    /// Record a BPF program attachment and check against whitelist
    pub async fn record_bpf_attach(&self, event: BpfEvent) -> Option<MalwareDetection> {
        if !self.ebpf_config.enabled {
            return None;
        }

        let is_whitelisted = self
            .ebpf_config
            .whitelist_processes
            .iter()
            .any(|name| event.process_name.contains(name));

        if !is_whitelisted {
            warn!(
                "Unauthorized BPF program attachment by process '{}' (PID: {}), type: {:?}",
                event.process_name, event.pid, event.program_type
            );

            let mut events = self.bpf_events.write().await;
            events.push(event.clone());

            // Check if this is a socket filter (commonly used by malware)
            let severity = match event.program_type {
                BpfProgramType::SocketFilter => Severity::Critical,
                BpfProgramType::Xdp => Severity::Critical,
                BpfProgramType::RawTracepoint => Severity::High,
                BpfProgramType::Kprobe => Severity::High,
                _ => Severity::Medium,
            };

            return Some(MalwareDetection {
                detection_type: DetectionType::UnauthorizedBpf,
                ip: None,
                details: format!(
                    "Unauthorized BPF {:?} by '{}' (PID: {})",
                    event.program_type, event.process_name, event.pid
                ),
                severity,
                should_ban: false, // Can't ban a process, but should alert
            });
        }

        if self.ebpf_config.alert_on_attach {
            debug!(
                "Whitelisted BPF attach by '{}' (PID: {})",
                event.process_name, event.pid
            );
        }

        None
    }

    /// Get detection statistics
    pub async fn get_stats(&self) -> MalwareDetectorStats {
        let port_access = self.port_access.read().await;
        let dns_trackers = self.dns_trackers.read().await;
        let bpf_events = self.bpf_events.read().await;

        MalwareDetectorStats {
            tracked_ips_port_hopping: port_access.len(),
            tracked_ips_dns: dns_trackers.len(),
            bpf_events_recorded: bpf_events.len(),
        }
    }

    /// Clean up old tracking data
    pub async fn cleanup(&self, max_age: Duration) {
        let now = Instant::now();

        // Clean port access
        {
            let mut port_access = self.port_access.write().await;
            port_access.retain(|_, access| now.duration_since(access.first_seen) < max_age);
        }

        // Clean DNS trackers
        {
            let mut trackers = self.dns_trackers.write().await;
            trackers.retain(|_, tracker| {
                tracker
                    .queries
                    .last()
                    .map(|(_, t)| now.duration_since(*t) < max_age)
                    .unwrap_or(false)
            });
        }

        // Clean old BPF events
        {
            let mut events = self.bpf_events.write().await;
            events.retain(|e| now.duration_since(e.timestamp) < max_age);
        }
    }
}

/// Statistics for the malware detector
#[derive(Debug, Clone)]
pub struct MalwareDetectorStats {
    pub tracked_ips_port_hopping: usize,
    pub tracked_ips_dns: usize,
    pub bpf_events_recorded: usize,
}

/// BPF syscall monitor using audit or ftrace
pub struct BpfSyscallMonitor {
    config: EbpfMalwareConfig,
    detector: Arc<MalwareDetector>,
}

impl BpfSyscallMonitor {
    pub fn new(config: EbpfMalwareConfig, detector: Arc<MalwareDetector>) -> Self {
        Self { config, detector }
    }

    /// Start monitoring BPF syscalls
    /// This uses /sys/kernel/debug/tracing/events/syscalls/sys_enter_bpf
    pub async fn start(&self) -> Result<()> {
        if !self.config.enabled || !self.config.monitor_bpf_syscalls {
            return Ok(());
        }

        info!("Starting BPF syscall monitor");

        // Check if we have access to ftrace
        let ftrace_path = "/sys/kernel/debug/tracing/events/syscalls/sys_enter_bpf/enable";
        if std::path::Path::new(ftrace_path).exists() {
            // Enable the tracepoint
            if let Err(e) = std::fs::write(ftrace_path, "1") {
                warn!(
                    "Could not enable BPF syscall tracing (needs root): {}",
                    e
                );
                return Ok(());
            }

            // In a real implementation, we'd read from trace_pipe
            // For now, we'll rely on the audit subsystem
            info!("BPF syscall tracing enabled");
        } else {
            warn!("BPF syscall tracing not available (missing ftrace)");
        }

        Ok(())
    }

    /// Parse an audit log line for BPF events
    pub fn parse_audit_line(&self, line: &str) -> Option<BpfEvent> {
        // Look for SYSCALL audit events for bpf (syscall 321 on x86_64)
        if !line.contains("SYSCALL") || !line.contains("syscall=321") {
            return None;
        }

        // Extract PID
        let pid = line
            .split_whitespace()
            .find(|s| s.starts_with("pid="))
            .and_then(|s| s.strip_prefix("pid="))
            .and_then(|s| s.parse().ok())
            .unwrap_or(0);

        // Extract comm (process name)
        let comm = line
            .split_whitespace()
            .find(|s| s.starts_with("comm="))
            .and_then(|s| s.strip_prefix("comm="))
            .map(|s| s.trim_matches('"').to_string())
            .unwrap_or_else(|| "unknown".to_string());

        // Extract a0 (BPF command/program type)
        let prog_type = line
            .split_whitespace()
            .find(|s| s.starts_with("a0="))
            .and_then(|s| s.strip_prefix("a0="))
            .and_then(|s| u32::from_str_radix(s, 16).ok())
            .unwrap_or(0);

        Some(BpfEvent {
            pid,
            process_name: comm,
            program_type: BpfProgramType::from(prog_type),
            timestamp: Instant::now(),
        })
    }
}

/// DNS traffic analyzer using NFQUEUE
pub struct DnsAnalyzer {
    config: DnsMonitorConfig,
    detector: Arc<MalwareDetector>,
}

impl DnsAnalyzer {
    pub fn new(config: DnsMonitorConfig, detector: Arc<MalwareDetector>) -> Self {
        Self { config, detector }
    }

    /// Parse DNS query from packet payload
    pub fn parse_dns_query(&self, payload: &[u8]) -> Option<(String, u16)> {
        // DNS header is 12 bytes, then QNAME, QTYPE, QCLASS
        if payload.len() < 17 {
            return None;
        }

        // Skip UDP header (8 bytes) if present
        let dns_start = if payload.len() > 20 && payload[2] == 0x00 && payload[3] == 0x35 {
            8 // UDP header
        } else {
            0
        };

        let dns = &payload[dns_start..];
        if dns.len() < 12 {
            return None;
        }

        // Parse QNAME (starts at offset 12)
        let mut offset = 12;
        let mut name_parts = Vec::new();

        while offset < dns.len() {
            let len = dns[offset] as usize;
            if len == 0 {
                offset += 1;
                break;
            }
            if len > 63 || offset + 1 + len > dns.len() {
                return None;
            }
            if let Ok(part) = std::str::from_utf8(&dns[offset + 1..offset + 1 + len]) {
                name_parts.push(part.to_string());
            }
            offset += 1 + len;
        }

        if name_parts.is_empty() || offset + 2 > dns.len() {
            return None;
        }

        let query_name = name_parts.join(".");
        let query_type = ((dns[offset] as u16) << 8) | (dns[offset + 1] as u16);

        Some((query_name, query_type))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_entropy_calculation() {
        // Low entropy (repeated characters)
        let low = calculate_entropy(b"aaaaaaaa");
        assert!(low < 1.0);

        // High entropy (random-looking)
        let high = calculate_entropy(b"aGVsbG8gd29ybGQ=");
        assert!(high > 3.0);

        // Medium entropy (normal text)
        let medium = calculate_entropy(b"hello world");
        assert!(medium > 2.0 && medium < 4.0);
    }

    #[test]
    fn test_bpf_program_type_conversion() {
        assert_eq!(BpfProgramType::from(1), BpfProgramType::SocketFilter);
        assert_eq!(BpfProgramType::from(6), BpfProgramType::Xdp);
        assert_eq!(BpfProgramType::from(999), BpfProgramType::Unknown(999));
    }
}
