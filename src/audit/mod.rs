//! Audit Logging Module
//!
//! Provides structured audit logging for packet processing, enabling
//! offline security analysis and compliance auditing.
//!
//! # Features
//!
//! - Complete audit records for every packet processed
//! - Per-stage metrics (latency, events generated, suggested actions)
//! - Multiple output formats: JSON Lines, CSV, CEF, ECS
//! - File rotation and buffered writes
//! - Flow context and detection event details
//!
//! # Example
//!
//! ```rust,no_run
//! use crmonban::audit::{AuditLogger, AuditConfig, AuditFormat};
//!
//! let config = AuditConfig {
//!     enabled: true,
//!     format: AuditFormat::JsonLines,
//!     output_path: "/var/log/crmonban/audit.jsonl".into(),
//!     ..Default::default()
//! };
//!
//! let logger = AuditLogger::new(config).unwrap();
//! ```

use std::fs::{File, OpenOptions};
use std::io::{BufWriter, Write};
use std::net::IpAddr;
use std::path::PathBuf;
use std::sync::Arc;
use std::time::{Duration, Instant};

use chrono::{DateTime, Utc};
use parking_lot::Mutex;
use serde::{Deserialize, Serialize};
use tracing::{debug, error, info};

use crate::core::{
    DetectionAction, DetectionEvent, Layer4, PacketAnalysis, Severity,
};

/// Complete audit record for each packet
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditRecord {
    /// Timestamp when packet was processed
    pub timestamp: DateTime<Utc>,
    /// Unique packet identifier
    pub packet_id: u64,
    /// Associated flow ID (if available)
    pub flow_id: Option<u64>,

    // Network metadata
    /// Source IP address
    pub src_ip: IpAddr,
    /// Destination IP address
    pub dst_ip: IpAddr,
    /// Source port (TCP/UDP)
    pub src_port: Option<u16>,
    /// Destination port (TCP/UDP)
    pub dst_port: Option<u16>,
    /// IP protocol
    pub protocol: String,
    /// Packet length in bytes
    pub packet_len: u32,

    /// Detection results per stage
    pub stages: Vec<StageResult>,

    /// What detection layers suggest (for logging)
    pub suggested_verdict: String,
    /// What policy decided (after severity checks)
    pub actual_verdict: String,
    /// True if suggested != actual and suggested was blocking
    pub would_block: bool,

    /// All detection events generated
    pub events: Vec<DetectionEventLog>,

    /// Flow statistics (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flow_stats: Option<FlowStatsLog>,

    /// Processing time in microseconds
    pub processing_time_us: u64,
    /// List of stages that processed this packet
    pub stages_passed: Vec<String>,
}

/// Result from a single pipeline stage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StageResult {
    /// Stage name (e.g., "ipfilter", "layer234", "signatures")
    pub stage: String,
    /// Did packet pass this stage without being marked for action?
    pub passed: bool,
    /// Did stage generate any events?
    pub marked: bool,
    /// Processing time for this stage in microseconds
    pub latency_us: u64,
    /// Number of events generated by this stage
    pub events_generated: u32,
    /// Suggested action from this stage (if any)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggested_action: Option<String>,
}

impl StageResult {
    /// Create a new stage result
    pub fn new(stage: &str) -> Self {
        Self {
            stage: stage.to_string(),
            passed: true,
            marked: false,
            latency_us: 0,
            events_generated: 0,
            suggested_action: None,
        }
    }

    /// Set the latency
    pub fn with_latency(mut self, latency: Duration) -> Self {
        self.latency_us = latency.as_micros() as u64;
        self
    }

    /// Set events generated
    pub fn with_events(mut self, count: u32, action: Option<DetectionAction>) -> Self {
        self.events_generated = count;
        self.marked = count > 0;
        if let Some(a) = action {
            self.suggested_action = Some(format!("{:?}", a));
        }
        self
    }
}

/// Logged detection event (serializable version of DetectionEvent)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DetectionEventLog {
    /// Event type (e.g., "PortScan", "BruteForce", "SignatureMatch")
    pub event_type: String,
    /// Severity level
    pub severity: String,
    /// Suggested action
    pub action: String,
    /// Human-readable message
    pub message: String,
    /// Confidence score (0.0-1.0)
    pub confidence: f32,
    /// Rule ID (if from signature matching)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_id: Option<u32>,
    /// Rule name (if from signature matching)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_name: Option<String>,
    /// Which detector/stage generated this
    pub detector: String,
    /// MITRE ATT&CK tactics
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub mitre_tactics: Vec<String>,
    /// MITRE ATT&CK techniques
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub mitre_techniques: Vec<String>,
}

impl From<&DetectionEvent> for DetectionEventLog {
    fn from(event: &DetectionEvent) -> Self {
        // Parse MITRE attack strings (format: "T1234.001") into tactics/techniques
        let mitre_techniques: Vec<String> = event.mitre_attack.clone();
        // Note: MITRE tactics would require lookup - for now just include techniques
        let mitre_tactics: Vec<String> = Vec::new();

        Self {
            event_type: format!("{:?}", event.event_type),
            severity: format!("{:?}", event.severity),
            action: format!("{:?}", event.action),
            message: event.message.clone(),
            confidence: event.confidence,
            rule_id: event.rule_id,
            rule_name: event.rule_name.clone(),
            detector: if event.detector.is_empty() { "unknown".to_string() } else { event.detector.clone() },
            mitre_tactics,
            mitre_techniques,
        }
    }
}

/// Flow statistics for audit logging
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FlowStatsLog {
    /// Packets sent forward
    pub packets_fwd: u64,
    /// Packets sent backward
    pub packets_bwd: u64,
    /// Bytes sent forward
    pub bytes_fwd: u64,
    /// Bytes sent backward
    pub bytes_bwd: u64,
    /// Flow duration in milliseconds
    pub duration_ms: u64,
    /// Detected application protocol
    pub app_protocol: String,
}

/// Audit output format
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum AuditFormat {
    /// JSON Lines (one JSON object per line) - default
    #[default]
    JsonLines,
    /// CSV format for spreadsheet analysis
    Csv,
    /// CEF (Common Event Format) for SIEMs
    Cef,
    /// ECS (Elastic Common Schema)
    Ecs,
}

/// Audit logger configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditConfig {
    /// Enable audit logging
    pub enabled: bool,
    /// Output format
    pub format: AuditFormat,
    /// Output file path
    pub output_path: PathBuf,
    /// Rotate when file reaches this size (MB)
    pub rotate_size_mb: u64,
    /// Number of rotated files to keep
    pub rotate_count: u32,
    /// Flush buffer every N seconds
    pub flush_interval_secs: u64,
    /// Include flow statistics in output
    pub include_flow_stats: bool,
    /// Include SHA256 hash of payload (privacy consideration)
    pub include_payload_hash: bool,
    /// Buffer size (number of records before auto-flush)
    pub buffer_size: usize,
    /// Only log packets with events (reduces volume)
    pub only_with_events: bool,
    /// Minimum severity to log (filter out lower)
    pub min_severity: Severity,
}

impl Default for AuditConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            format: AuditFormat::JsonLines,
            output_path: PathBuf::from("/var/log/crmonban/audit.jsonl"),
            rotate_size_mb: 100,
            rotate_count: 10,
            flush_interval_secs: 5,
            include_flow_stats: true,
            include_payload_hash: false,
            buffer_size: 1000,
            only_with_events: false,
            min_severity: Severity::Info,
        }
    }
}

/// Audit logger for packet processing
pub struct AuditLogger {
    /// Configuration
    config: AuditConfig,
    /// Output writer (wrapped in Arc<Mutex> for thread safety)
    writer: Arc<Mutex<BufWriter<File>>>,
    /// Buffer for batch writes
    buffer: Arc<Mutex<Vec<AuditRecord>>>,
    /// Current file size estimate
    current_size: Arc<Mutex<u64>>,
    /// Last flush time
    last_flush: Arc<Mutex<Instant>>,
    /// Records written (stats)
    records_written: Arc<Mutex<u64>>,
}

impl AuditLogger {
    /// Create a new audit logger
    pub fn new(config: AuditConfig) -> Result<Self, std::io::Error> {
        if !config.enabled {
            // Create a dummy logger that won't write
            let file = OpenOptions::new()
                .write(true)
                .create(true)
                .append(true)
                .open("/dev/null")?;
            return Ok(Self {
                config,
                writer: Arc::new(Mutex::new(BufWriter::new(file))),
                buffer: Arc::new(Mutex::new(Vec::new())),
                current_size: Arc::new(Mutex::new(0)),
                last_flush: Arc::new(Mutex::new(Instant::now())),
                records_written: Arc::new(Mutex::new(0)),
            });
        }

        // Ensure parent directory exists
        if let Some(parent) = config.output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        let file = OpenOptions::new()
            .write(true)
            .create(true)
            .append(true)
            .open(&config.output_path)?;

        let current_size = file.metadata()?.len();

        info!(
            "Audit logger initialized: {:?} -> {}",
            config.format,
            config.output_path.display()
        );

        Ok(Self {
            config,
            writer: Arc::new(Mutex::new(BufWriter::new(file))),
            buffer: Arc::new(Mutex::new(Vec::with_capacity(1000))),
            current_size: Arc::new(Mutex::new(current_size)),
            last_flush: Arc::new(Mutex::new(Instant::now())),
            records_written: Arc::new(Mutex::new(0)),
        })
    }

    /// Log an audit record
    pub fn log(&self, record: AuditRecord) {
        if !self.config.enabled {
            return;
        }

        // Filter by severity if configured
        if self.config.only_with_events && record.events.is_empty() {
            return;
        }

        // Check minimum severity
        let max_severity = record
            .events
            .iter()
            .map(|e| severity_from_string(&e.severity))
            .max()
            .unwrap_or(Severity::Info);

        if max_severity < self.config.min_severity && !record.events.is_empty() {
            return;
        }

        let mut buffer = self.buffer.lock();
        buffer.push(record);

        // Check if we should flush
        let should_flush = buffer.len() >= self.config.buffer_size
            || self.last_flush.lock().elapsed().as_secs() >= self.config.flush_interval_secs;

        if should_flush {
            drop(buffer); // Release lock before flushing
            self.flush();
        }
    }

    /// Flush buffered records to disk
    pub fn flush(&self) {
        let records: Vec<AuditRecord> = {
            let mut buffer = self.buffer.lock();
            std::mem::take(&mut *buffer)
        };

        if records.is_empty() {
            return;
        }

        let mut writer = self.writer.lock();
        let mut size_added: u64 = 0;

        for record in &records {
            match self.config.format {
                AuditFormat::JsonLines => {
                    if let Ok(json) = serde_json::to_string(&record) {
                        size_added += json.len() as u64 + 1;
                        if let Err(e) = writeln!(writer, "{}", json) {
                            error!("Failed to write audit record: {}", e);
                        }
                    }
                }
                AuditFormat::Csv => {
                    let line = self.format_csv(&record);
                    size_added += line.len() as u64 + 1;
                    if let Err(e) = writeln!(writer, "{}", line) {
                        error!("Failed to write audit record: {}", e);
                    }
                }
                AuditFormat::Cef => {
                    let line = self.format_cef(&record);
                    size_added += line.len() as u64 + 1;
                    if let Err(e) = writeln!(writer, "{}", line) {
                        error!("Failed to write audit record: {}", e);
                    }
                }
                AuditFormat::Ecs => {
                    if let Ok(json) = self.format_ecs(&record) {
                        size_added += json.len() as u64 + 1;
                        if let Err(e) = writeln!(writer, "{}", json) {
                            error!("Failed to write audit record: {}", e);
                        }
                    }
                }
            }
        }

        if let Err(e) = writer.flush() {
            error!("Failed to flush audit log: {}", e);
        }

        // Update stats
        *self.records_written.lock() += records.len() as u64;
        *self.last_flush.lock() = Instant::now();
        *self.current_size.lock() += size_added;

        // Check if rotation needed
        let current_size = *self.current_size.lock();
        if current_size > self.config.rotate_size_mb * 1024 * 1024 {
            drop(writer); // Release lock before rotating
            self.rotate();
        }

        debug!("Flushed {} audit records", records.len());
    }

    /// Rotate log files
    fn rotate(&self) {
        let path = &self.config.output_path;

        // Rotate existing files
        for i in (1..self.config.rotate_count).rev() {
            let old = path.with_extension(format!("jsonl.{}", i));
            let new = path.with_extension(format!("jsonl.{}", i + 1));
            if old.exists() {
                let _ = std::fs::rename(&old, &new);
            }
        }

        // Rename current to .1
        let rotated = path.with_extension("jsonl.1");
        if path.exists() {
            let _ = std::fs::rename(path, &rotated);
        }

        // Create new file
        match OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(path)
        {
            Ok(file) => {
                *self.writer.lock() = BufWriter::new(file);
                *self.current_size.lock() = 0;
                info!("Rotated audit log: {}", path.display());
            }
            Err(e) => {
                error!("Failed to rotate audit log: {}", e);
            }
        }
    }

    /// Format record as CSV
    fn format_csv(&self, record: &AuditRecord) -> String {
        format!(
            "{},{},{},{},{},{},{},{},{},{},{},{}",
            record.timestamp.to_rfc3339(),
            record.packet_id,
            record.src_ip,
            record.dst_ip,
            record.src_port.unwrap_or(0),
            record.dst_port.unwrap_or(0),
            record.protocol,
            record.packet_len,
            record.suggested_verdict,
            record.actual_verdict,
            record.would_block,
            record.events.len()
        )
    }

    /// Format record as CEF (Common Event Format)
    fn format_cef(&self, record: &AuditRecord) -> String {
        let severity = if record.would_block { 8 } else { 3 };
        let event_name = if record.events.is_empty() {
            "PacketProcessed"
        } else {
            &record.events[0].event_type
        };

        format!(
            "CEF:0|CrmonBan|IDS|1.0|{}|{}|{}|src={} dst={} spt={} dpt={} proto={} act={} outcome={}",
            record.packet_id,
            event_name,
            severity,
            record.src_ip,
            record.dst_ip,
            record.src_port.unwrap_or(0),
            record.dst_port.unwrap_or(0),
            record.protocol,
            record.actual_verdict,
            if record.actual_verdict == "Accept" {
                "success"
            } else {
                "blocked"
            }
        )
    }

    /// Format record as ECS (Elastic Common Schema)
    fn format_ecs(&self, record: &AuditRecord) -> Result<String, serde_json::Error> {
        let ecs = serde_json::json!({
            "@timestamp": record.timestamp.to_rfc3339(),
            "event": {
                "kind": "event",
                "category": ["network"],
                "type": if record.would_block { ["denied"] } else { ["allowed"] },
                "outcome": if record.actual_verdict == "Accept" { "success" } else { "failure" },
                "duration": record.processing_time_us * 1000  // nanoseconds
            },
            "source": {
                "ip": record.src_ip.to_string(),
                "port": record.src_port
            },
            "destination": {
                "ip": record.dst_ip.to_string(),
                "port": record.dst_port
            },
            "network": {
                "transport": record.protocol.to_lowercase(),
                "bytes": record.packet_len
            },
            "crmonban": {
                "packet_id": record.packet_id,
                "suggested_verdict": record.suggested_verdict,
                "actual_verdict": record.actual_verdict,
                "would_block": record.would_block,
                "events": record.events,
                "stages": record.stages
            }
        });
        serde_json::to_string(&ecs)
    }

    /// Create audit record from packet analysis
    pub fn create_record(
        &self,
        analysis: &PacketAnalysis,
        stage_results: Vec<StageResult>,
        processing_time: Duration,
    ) -> AuditRecord {
        let packet = &analysis.packet;

        // Extract port info from Layer4
        let (src_port, dst_port) = match &packet.layer4 {
            Layer4::Tcp(tcp) => (Some(tcp.src_port), Some(tcp.dst_port)),
            Layer4::Udp(udp) => (Some(udp.src_port), Some(udp.dst_port)),
            _ => (None, None),
        };

        // Convert events
        let events: Vec<DetectionEventLog> =
            analysis.events.iter().map(DetectionEventLog::from).collect();

        // Extract flow stats if available
        let flow_stats = if self.config.include_flow_stats {
            analysis.flow.as_ref().map(|f| {
                let stats = f.stats();
                FlowStatsLog {
                    packets_fwd: stats.total_fwd_packets,
                    packets_bwd: stats.total_bwd_packets,
                    bytes_fwd: stats.total_fwd_bytes,
                    bytes_bwd: stats.total_bwd_bytes,
                    duration_ms: stats.duration_us / 1000,
                    app_protocol: format!("{:?}", f.app_protocol),
                }
            })
        } else {
            None
        };

        // Collect stage names
        let stages_passed: Vec<String> = stage_results.iter().map(|s| s.stage.clone()).collect();

        AuditRecord {
            timestamp: Utc::now(),
            packet_id: packet.id,
            flow_id: analysis.flow.as_ref().map(|f| f.id),
            src_ip: packet.src_ip(),
            dst_ip: packet.dst_ip(),
            src_port,
            dst_port,
            protocol: format!("{:?}", packet.protocol()),
            packet_len: packet.raw_len,
            stages: stage_results,
            suggested_verdict: format!("{:?}", analysis.suggested_verdict),
            actual_verdict: format!("{:?}", analysis.verdict),
            would_block: analysis.would_block(),
            events,
            flow_stats,
            processing_time_us: processing_time.as_micros() as u64,
            stages_passed,
        }
    }

    /// Get statistics
    pub fn stats(&self) -> AuditStats {
        AuditStats {
            records_written: *self.records_written.lock(),
            current_file_size: *self.current_size.lock(),
            buffer_size: self.buffer.lock().len(),
        }
    }

    /// Check if logger is enabled
    pub fn is_enabled(&self) -> bool {
        self.config.enabled
    }
}

impl Drop for AuditLogger {
    fn drop(&mut self) {
        // Flush remaining records on drop
        self.flush();
    }
}

/// Audit logger statistics
#[derive(Debug, Clone)]
pub struct AuditStats {
    /// Total records written
    pub records_written: u64,
    /// Current file size in bytes
    pub current_file_size: u64,
    /// Current buffer size
    pub buffer_size: usize,
}

/// Helper to convert severity string back to enum
fn severity_from_string(s: &str) -> Severity {
    match s {
        "Critical" => Severity::Critical,
        "High" => Severity::High,
        "Medium" => Severity::Medium,
        "Low" => Severity::Low,
        _ => Severity::Info,
    }
}

/// Stage timing helper for collecting per-stage metrics
pub struct StageTimer {
    stage_name: String,
    start: Instant,
    events_before: usize,
}

impl StageTimer {
    /// Start timing a stage
    pub fn start(stage_name: &str, events_before: usize) -> Self {
        Self {
            stage_name: stage_name.to_string(),
            start: Instant::now(),
            events_before,
        }
    }

    /// Finish timing and create result
    pub fn finish(self, analysis: &PacketAnalysis) -> StageResult {
        let events_after = analysis.events.len();
        let events_generated = (events_after - self.events_before) as u32;

        // Find highest priority action from new events
        // Priority: Ban > Drop > Reject > RateLimit > Alert > Log > Allow
        let suggested_action = analysis.events[self.events_before..]
            .iter()
            .map(|e| e.action)
            .max_by_key(|a| action_priority(*a));

        StageResult {
            stage: self.stage_name,
            passed: true, // Could be set to false if stage aborted
            marked: events_generated > 0,
            latency_us: self.start.elapsed().as_micros() as u64,
            events_generated,
            suggested_action: suggested_action.map(|a| format!("{:?}", a)),
        }
    }
}

/// Action priority for comparison (higher = more severe)
fn action_priority(action: DetectionAction) -> u8 {
    match action {
        DetectionAction::Allow => 0,
        DetectionAction::Log => 1,
        DetectionAction::Alert => 2,
        DetectionAction::RateLimit => 3,
        DetectionAction::Reject => 4,
        DetectionAction::Drop => 5,
        DetectionAction::Ban => 6,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr};
    use tempfile::TempDir;
    use crate::core::{Packet, IpProtocol, DetectionType};

    fn make_test_packet() -> Packet {
        Packet::new(
            1,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            IpProtocol::Tcp,
            "eth0",
        )
    }

    #[test]
    fn test_audit_config_default() {
        let config = AuditConfig::default();
        assert!(config.enabled);
        assert_eq!(config.format, AuditFormat::JsonLines);
        assert_eq!(config.buffer_size, 1000);
    }

    #[test]
    fn test_audit_logger_creation() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("audit.jsonl");

        let config = AuditConfig {
            output_path: path.clone(),
            ..Default::default()
        };

        let logger = AuditLogger::new(config).unwrap();
        assert!(logger.is_enabled());
    }

    #[test]
    fn test_audit_record_creation() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("audit.jsonl");

        let config = AuditConfig {
            output_path: path,
            ..Default::default()
        };

        let logger = AuditLogger::new(config).unwrap();
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet);

        let stage_results = vec![
            StageResult::new("ipfilter").with_latency(Duration::from_micros(5)),
            StageResult::new("layer234").with_latency(Duration::from_micros(100)),
        ];

        let record = logger.create_record(&analysis, stage_results, Duration::from_micros(150));

        assert_eq!(record.src_ip, IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)));
        assert_eq!(record.dst_ip, IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)));
        assert_eq!(record.stages.len(), 2);
        assert_eq!(record.processing_time_us, 150);
    }

    #[test]
    fn test_audit_log_and_flush() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("audit.jsonl");

        let config = AuditConfig {
            output_path: path.clone(),
            buffer_size: 2, // Small buffer for testing
            ..Default::default()
        };

        let logger = AuditLogger::new(config).unwrap();
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet);

        let record = logger.create_record(&analysis, vec![], Duration::from_micros(10));

        // Log some records
        logger.log(record.clone());
        logger.log(record.clone());
        logger.log(record);

        // Force flush
        logger.flush();

        // Check file has content
        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("192.168.1.100"));
        assert!(content.lines().count() >= 2);
    }

    #[test]
    fn test_detection_event_log_conversion() {
        let event = DetectionEvent::new(
            DetectionType::PortScan,
            Severity::High,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test scan detected".to_string(),
        )
        .with_action(DetectionAction::Alert)
        .with_confidence(0.85);

        let log: DetectionEventLog = (&event).into();

        assert_eq!(log.event_type, "PortScan");
        assert_eq!(log.severity, "High");
        assert_eq!(log.confidence, 0.85);
    }

    #[test]
    fn test_stage_result_builder() {
        let result = StageResult::new("signatures")
            .with_latency(Duration::from_micros(250))
            .with_events(3, Some(DetectionAction::Drop));

        assert_eq!(result.stage, "signatures");
        assert_eq!(result.latency_us, 250);
        assert_eq!(result.events_generated, 3);
        assert!(result.marked);
        assert_eq!(result.suggested_action, Some("Drop".to_string()));
    }

    #[test]
    fn test_csv_format() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("audit.csv");

        let config = AuditConfig {
            output_path: path.clone(),
            format: AuditFormat::Csv,
            buffer_size: 1,
            ..Default::default()
        };

        let logger = AuditLogger::new(config).unwrap();
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet);
        let record = logger.create_record(&analysis, vec![], Duration::from_micros(10));

        logger.log(record);
        logger.flush();

        let content = std::fs::read_to_string(&path).unwrap();
        // CSV should have commas
        assert!(content.contains(","));
        assert!(content.contains("192.168.1.100"));
    }

    #[test]
    fn test_cef_format() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("audit.cef");

        let config = AuditConfig {
            output_path: path.clone(),
            format: AuditFormat::Cef,
            buffer_size: 1,
            ..Default::default()
        };

        let logger = AuditLogger::new(config).unwrap();
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet);
        let record = logger.create_record(&analysis, vec![], Duration::from_micros(10));

        logger.log(record);
        logger.flush();

        let content = std::fs::read_to_string(&path).unwrap();
        // CEF should start with CEF:0
        assert!(content.starts_with("CEF:0"));
        assert!(content.contains("CrmonBan"));
    }

    #[test]
    fn test_stage_timer() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);

        // Start timing
        let timer = StageTimer::start("test_stage", analysis.events.len());

        // Simulate adding events
        analysis.add_event(DetectionEvent::new(
            DetectionType::PortScan,
            Severity::Medium,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test".to_string(),
        ));

        // Finish timing
        let result = timer.finish(&analysis);

        assert_eq!(result.stage, "test_stage");
        assert_eq!(result.events_generated, 1);
        assert!(result.marked);
        assert!(result.latency_us > 0);
    }

    #[test]
    fn test_disabled_logger() {
        let config = AuditConfig {
            enabled: false,
            ..Default::default()
        };

        let logger = AuditLogger::new(config).unwrap();
        assert!(!logger.is_enabled());

        // Should not panic when logging to disabled logger
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet);
        let record = logger.create_record(&analysis, vec![], Duration::from_micros(10));
        logger.log(record);
    }

    #[test]
    fn test_only_with_events_filter() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("audit.jsonl");

        let config = AuditConfig {
            output_path: path.clone(),
            only_with_events: true,
            buffer_size: 1,
            ..Default::default()
        };

        let logger = AuditLogger::new(config).unwrap();
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet); // No events

        let record = logger.create_record(&analysis, vec![], Duration::from_micros(10));
        logger.log(record);
        logger.flush();

        // File should be empty (record was filtered)
        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.is_empty());
    }
}
