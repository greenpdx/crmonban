//! Packet analysis context passed between pipeline stages
//!
//! The `PacketAnalysis` struct bundles together the packet being analyzed,
//! flow state, detection events, and flow control flags. Each pipeline stage
//! receives a `PacketAnalysis`, potentially modifies it, and returns it.

use serde::{Deserialize, Serialize};

use super::event::DetectionEvent;
use super::flow::Flow;
use super::packet::Packet;
use super::protocols::ProtocolEvent;

/// Verdict for packet after pipeline processing
///
/// Determines what happens to the packet after all stages have processed it.
/// Used by NFQUEUE to accept/drop/reject packets in real-time.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum PacketVerdict {
    /// Allow packet through (default)
    #[default]
    Accept,
    /// Drop packet silently
    Drop,
    /// Reject packet with RST (TCP) or ICMP unreachable (UDP)
    Reject,
    /// Re-queue to another NFQUEUE queue number
    Queue(u16),
}

impl PacketVerdict {
    /// Check if this verdict will block the packet
    #[inline]
    pub fn is_blocking(&self) -> bool {
        matches!(self, PacketVerdict::Drop | PacketVerdict::Reject)
    }

    /// Convert to string for logging
    pub fn as_str(&self) -> &'static str {
        match self {
            PacketVerdict::Accept => "accept",
            PacketVerdict::Drop => "drop",
            PacketVerdict::Reject => "reject",
            PacketVerdict::Queue(_) => "queue",
        }
    }
}

impl std::fmt::Display for PacketVerdict {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PacketVerdict::Accept => write!(f, "Accept"),
            PacketVerdict::Drop => write!(f, "Drop"),
            PacketVerdict::Reject => write!(f, "Reject"),
            PacketVerdict::Queue(q) => write!(f, "Queue({})", q),
        }
    }
}

/// Analysis context passed between pipeline stages
///
/// Each stage receives this, may add events or update flow/control,
/// and returns it for the next stage.
#[derive(Debug)]
pub struct PacketAnalysis {
    /// The packet being analyzed
    pub packet: Packet,

    /// Associated flow (populated by FlowTracker stage)
    pub flow: Option<Flow>,

    /// Events generated by stages
    pub events: Vec<DetectionEvent>,

    /// Parsed protocol events (populated by ProtocolAnalysis stage)
    /// Available to attack engines and later stages (ML, correlation)
    pub protocol_events: Vec<ProtocolEvent>,

    /// Flow control flags
    pub control: FlowControl,

    /// Actual verdict after applying severity policy
    /// This is what NFQUEUE will use to accept/drop the packet
    pub verdict: PacketVerdict,

    /// Suggested verdict from detection stages (before policy)
    /// Shows what stages wanted to do, for logging/visibility
    pub suggested_verdict: PacketVerdict,
}

impl PacketAnalysis {
    /// Create a new PacketAnalysis from a packet
    pub fn new(packet: Packet) -> Self {
        Self {
            packet,
            flow: None,
            events: Vec::new(),
            protocol_events: Vec::new(),
            control: FlowControl::default(),
            verdict: PacketVerdict::Accept,
            suggested_verdict: PacketVerdict::Accept,
        }
    }

    /// Add a protocol event
    #[inline]
    pub fn add_protocol_event(&mut self, event: ProtocolEvent) {
        self.protocol_events.push(event);
    }

    /// Add multiple protocol events
    #[inline]
    pub fn add_protocol_events(&mut self, events: impl IntoIterator<Item = ProtocolEvent>) {
        self.protocol_events.extend(events);
    }

    /// Get HTTP transactions from protocol events
    pub fn http_transactions(&self) -> impl Iterator<Item = &super::protocols::HttpTransaction> {
        self.protocol_events.iter().filter_map(|e| {
            if let ProtocolEvent::Http(tx) = e {
                Some(tx)
            } else {
                None
            }
        })
    }

    /// Get DNS messages from protocol events
    pub fn dns_messages(&self) -> impl Iterator<Item = &super::protocols::DnsMessage> {
        self.protocol_events.iter().filter_map(|e| {
            if let ProtocolEvent::Dns(msg) = e {
                Some(msg)
            } else {
                None
            }
        })
    }

    /// Get TLS events from protocol events
    pub fn tls_events(&self) -> impl Iterator<Item = &super::protocols::TlsEvent> {
        self.protocol_events.iter().filter_map(|e| {
            if let ProtocolEvent::Tls(tls) = e {
                Some(tls)
            } else {
                None
            }
        })
    }

    /// Add a detection event
    #[inline]
    pub fn add_event(&mut self, event: DetectionEvent) {
        if !self.control.suppress_events {
            self.events.push(event);
            self.control.marked = true;
        }
    }

    /// Add multiple detection events
    #[inline]
    pub fn add_events(&mut self, events: impl IntoIterator<Item = DetectionEvent>) {
        if !self.control.suppress_events {
            for event in events {
                self.events.push(event);
                self.control.marked = true;
            }
        }
    }

    /// Set the flow
    #[inline]
    pub fn set_flow(&mut self, flow: Flow) {
        self.flow = Some(flow);
    }

    /// Check if processing should continue
    #[inline]
    pub fn should_continue(&self) -> bool {
        !self.control.stop_processing
    }

    /// Mark to stop processing further stages
    #[inline]
    pub fn stop(&mut self) {
        self.control.stop_processing = true;
    }

    /// Check if any stage has marked this packet
    #[inline]
    pub fn is_marked(&self) -> bool {
        self.control.marked
    }

    /// Get event count
    #[inline]
    pub fn event_count(&self) -> usize {
        self.events.len()
    }

    /// Take ownership of events (consumes them)
    #[inline]
    pub fn take_events(&mut self) -> Vec<DetectionEvent> {
        std::mem::take(&mut self.events)
    }

    /// Check if we have a flow
    #[inline]
    pub fn has_flow(&self) -> bool {
        self.flow.is_some()
    }

    /// Get flow reference
    #[inline]
    pub fn flow(&self) -> Option<&Flow> {
        self.flow.as_ref()
    }

    /// Get mutable flow reference
    #[inline]
    pub fn flow_mut(&mut self) -> Option<&mut Flow> {
        self.flow.as_mut()
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Verdict Methods
    // ═══════════════════════════════════════════════════════════════════════

    /// Set the actual verdict (after policy evaluation)
    #[inline]
    pub fn set_verdict(&mut self, verdict: PacketVerdict) {
        self.verdict = verdict;
    }

    /// Get the actual verdict
    #[inline]
    pub fn verdict(&self) -> PacketVerdict {
        self.verdict
    }

    /// Set the suggested verdict (what stages want)
    #[inline]
    pub fn set_suggested_verdict(&mut self, verdict: PacketVerdict) {
        self.suggested_verdict = verdict;
    }

    /// Get the suggested verdict
    #[inline]
    pub fn suggested_verdict(&self) -> PacketVerdict {
        self.suggested_verdict
    }

    /// Check if the packet should be dropped
    #[inline]
    pub fn should_drop(&self) -> bool {
        self.verdict.is_blocking()
    }

    /// Check if stages wanted to block but policy allowed
    /// Useful for logging "would have been blocked" packets
    #[inline]
    pub fn would_block(&self) -> bool {
        self.suggested_verdict.is_blocking() && !self.verdict.is_blocking()
    }

    /// Suggest dropping the packet (stages call this, policy decides later)
    #[inline]
    pub fn suggest_drop(&mut self) {
        self.suggested_verdict = PacketVerdict::Drop;
    }

    /// Suggest rejecting the packet (stages call this, policy decides later)
    #[inline]
    pub fn suggest_reject(&mut self) {
        self.suggested_verdict = PacketVerdict::Reject;
    }
}

/// Flow control flags for pipeline processing
#[derive(Debug, Clone, Default)]
pub struct FlowControl {
    /// Skip remaining stages (e.g., confirmed malicious already)
    pub stop_processing: bool,

    /// Don't generate more events for this packet
    pub suppress_events: bool,

    /// Packet has been marked by at least one stage
    pub marked: bool,
}

impl FlowControl {
    /// Create new flow control with defaults
    pub fn new() -> Self {
        Self::default()
    }

    /// Create flow control that stops processing
    pub fn stop() -> Self {
        Self {
            stop_processing: true,
            suppress_events: false,
            marked: false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::super::event::{DetectionType, Severity};
    use super::super::packet::IpProtocol;
    use std::net::{IpAddr, Ipv4Addr};

    fn make_test_packet() -> Packet {
        Packet::new(
            0,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            IpProtocol::Tcp,
            "lo",
        )
    }

    #[test]
    fn test_packet_analysis_new() {
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet);

        assert!(analysis.flow.is_none());
        assert!(analysis.events.is_empty());
        assert!(!analysis.control.stop_processing);
        assert!(!analysis.control.marked);
    }

    #[test]
    fn test_add_event() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);

        let event = DetectionEvent::new(
            DetectionType::PortScan,
            Severity::Medium,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test event".to_string(),
        );

        analysis.add_event(event);

        assert_eq!(analysis.events.len(), 1);
        assert!(analysis.is_marked());
    }

    #[test]
    fn test_suppress_events() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);
        analysis.control.suppress_events = true;

        let event = DetectionEvent::new(
            DetectionType::PortScan,
            Severity::Medium,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test event".to_string(),
        );

        analysis.add_event(event);

        assert!(analysis.events.is_empty());
        assert!(!analysis.is_marked());
    }

    #[test]
    fn test_stop_processing() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);

        assert!(analysis.should_continue());

        analysis.stop();

        assert!(!analysis.should_continue());
    }

    #[test]
    fn test_take_events() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);

        let event = DetectionEvent::new(
            DetectionType::PortScan,
            Severity::Medium,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test event".to_string(),
        );

        analysis.add_event(event);

        let events = analysis.take_events();
        assert_eq!(events.len(), 1);
        assert!(analysis.events.is_empty());
    }
}
