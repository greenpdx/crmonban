//! Packet analysis context passed between pipeline stages
//!
//! The `PacketAnalysis` struct bundles together the packet being analyzed,
//! flow state, detection events, and flow control flags. Each pipeline stage
//! receives a `PacketAnalysis`, potentially modifies it, and returns it.

use crate::core::event::DetectionEvent;
use crate::core::flow::Flow;
use crate::core::packet::Packet;

/// Analysis context passed between pipeline stages
///
/// Each stage receives this, may add events or update flow/control,
/// and returns it for the next stage.
#[derive(Debug)]
pub struct PacketAnalysis {
    /// The packet being analyzed
    pub packet: Packet,

    /// Associated flow (populated by FlowTracker stage)
    pub flow: Option<Flow>,

    /// Events generated by stages
    pub events: Vec<DetectionEvent>,

    /// Flow control flags
    pub control: FlowControl,
}

impl PacketAnalysis {
    /// Create a new PacketAnalysis from a packet
    pub fn new(packet: Packet) -> Self {
        Self {
            packet,
            flow: None,
            events: Vec::new(),
            control: FlowControl::default(),
        }
    }

    /// Add a detection event
    #[inline]
    pub fn add_event(&mut self, event: DetectionEvent) {
        if !self.control.suppress_events {
            self.events.push(event);
            self.control.marked = true;
        }
    }

    /// Add multiple detection events
    #[inline]
    pub fn add_events(&mut self, events: impl IntoIterator<Item = DetectionEvent>) {
        if !self.control.suppress_events {
            for event in events {
                self.events.push(event);
                self.control.marked = true;
            }
        }
    }

    /// Set the flow
    #[inline]
    pub fn set_flow(&mut self, flow: Flow) {
        self.flow = Some(flow);
    }

    /// Check if processing should continue
    #[inline]
    pub fn should_continue(&self) -> bool {
        !self.control.stop_processing
    }

    /// Mark to stop processing further stages
    #[inline]
    pub fn stop(&mut self) {
        self.control.stop_processing = true;
    }

    /// Check if any stage has marked this packet
    #[inline]
    pub fn is_marked(&self) -> bool {
        self.control.marked
    }

    /// Get event count
    #[inline]
    pub fn event_count(&self) -> usize {
        self.events.len()
    }

    /// Take ownership of events (consumes them)
    #[inline]
    pub fn take_events(&mut self) -> Vec<DetectionEvent> {
        std::mem::take(&mut self.events)
    }

    /// Check if we have a flow
    #[inline]
    pub fn has_flow(&self) -> bool {
        self.flow.is_some()
    }

    /// Get flow reference
    #[inline]
    pub fn flow(&self) -> Option<&Flow> {
        self.flow.as_ref()
    }

    /// Get mutable flow reference
    #[inline]
    pub fn flow_mut(&mut self) -> Option<&mut Flow> {
        self.flow.as_mut()
    }
}

/// Flow control flags for pipeline processing
#[derive(Debug, Clone, Default)]
pub struct FlowControl {
    /// Skip remaining stages (e.g., confirmed malicious already)
    pub stop_processing: bool,

    /// Don't generate more events for this packet
    pub suppress_events: bool,

    /// Packet has been marked by at least one stage
    pub marked: bool,
}

impl FlowControl {
    /// Create new flow control with defaults
    pub fn new() -> Self {
        Self::default()
    }

    /// Create flow control that stops processing
    pub fn stop() -> Self {
        Self {
            stop_processing: true,
            suppress_events: false,
            marked: false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::event::{DetectionType, Severity};
    use crate::core::packet::IpProtocol;
    use std::net::{IpAddr, Ipv4Addr};

    fn make_test_packet() -> Packet {
        Packet::new(
            0,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            IpProtocol::Tcp,
            "lo",
        )
    }

    #[test]
    fn test_packet_analysis_new() {
        let packet = make_test_packet();
        let analysis = PacketAnalysis::new(packet);

        assert!(analysis.flow.is_none());
        assert!(analysis.events.is_empty());
        assert!(!analysis.control.stop_processing);
        assert!(!analysis.control.marked);
    }

    #[test]
    fn test_add_event() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);

        let event = DetectionEvent::new(
            DetectionType::PortScan,
            Severity::Medium,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test event".to_string(),
        );

        analysis.add_event(event);

        assert_eq!(analysis.events.len(), 1);
        assert!(analysis.is_marked());
    }

    #[test]
    fn test_suppress_events() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);
        analysis.control.suppress_events = true;

        let event = DetectionEvent::new(
            DetectionType::PortScan,
            Severity::Medium,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test event".to_string(),
        );

        analysis.add_event(event);

        assert!(analysis.events.is_empty());
        assert!(!analysis.is_marked());
    }

    #[test]
    fn test_stop_processing() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);

        assert!(analysis.should_continue());

        analysis.stop();

        assert!(!analysis.should_continue());
    }

    #[test]
    fn test_take_events() {
        let packet = make_test_packet();
        let mut analysis = PacketAnalysis::new(packet);

        let event = DetectionEvent::new(
            DetectionType::PortScan,
            Severity::Medium,
            IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)),
            "Test event".to_string(),
        );

        analysis.add_event(event);

        let events = analysis.take_events();
        assert_eq!(events.len(), 1);
        assert!(analysis.events.is_empty());
    }
}
