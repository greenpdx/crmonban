# crmonban Configuration File
# nftables-based intrusion prevention system

[general]
# Path to SQLite database
db_path = "/var/lib/crmonban/crmonban.db"

# Path to PID file for daemon mode
pid_file = "/var/run/crmonban.pid"

# Log level: trace, debug, info, warn, error
log_level = "debug"

# Automatically gather intelligence when banning an IP
auto_intel = true

# Default ban duration in seconds (0 = permanent)
default_ban_duration = 3600

[nftables]
# nftables table name
table_name = "crmonban"

# Chain name for input filtering
chain_name = "input"

# Set name for blocked IPv4 addresses
set_v4 = "blocked_v4"

# Set name for blocked IPv6 addresses
set_v6 = "blocked_v6"

# Chain priority (lower = earlier in chain)
priority = -100

[intel]
# Enable GeoIP lookups (uses ip-api.com, free)
geoip_enabled = true

# Enable reverse DNS lookups
rdns_enabled = true

# Enable WHOIS lookups (uses RDAP)
whois_enabled = true

# Shodan API key (optional, get from shodan.io)
# shodan_api_key = "your-api-key-here"

# AbuseIPDB API key (optional, get from abuseipdb.com)
# abuseipdb_api_key = "your-api-key-here"

# Request timeout in seconds
timeout_secs = 10

# ============================================================================
# Service Monitoring Configuration
# ============================================================================
# Each service defines:
#   - enabled: whether to monitor this service
#   - log_path: path to the log file
#   - patterns: list of regex patterns (must have 'ip' named capture group)
#   - max_failures: number of failures before ban
#   - find_time: time window in seconds to count failures
#   - ban_time: ban duration in seconds

[services.ssh]
enabled = true
log_path = "/var/log/auth.log"
max_failures = 5
find_time = 600      # 10 minutes
ban_time = 3600      # 1 hour

[[services.ssh.patterns]]
name = "failed_password"
regex = 'Failed password for .* from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "failed_auth"

[[services.ssh.patterns]]
name = "invalid_user"
regex = 'Invalid user .* from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "invalid_user"

[[services.ssh.patterns]]
name = "connection_closed_preauth"
regex = 'Connection closed by (?P<ip>\d+\.\d+\.\d+\.\d+) port \d+ \[preauth\]'
event_type = "failed_auth"

[[services.ssh.patterns]]
name = "too_many_auth_failures"
regex = 'Disconnecting authenticating user .* (?P<ip>\d+\.\d+\.\d+\.\d+) .* Too many authentication failures'
event_type = "brute_force"

# Additional SSH attack patterns from real-world logs
[[services.ssh.patterns]]
name = "failed_password_root"
regex = 'Failed password for root from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "brute_force"

[[services.ssh.patterns]]
name = "refused_connect"
regex = 'refused connect from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "failed_auth"

[[services.ssh.patterns]]
name = "did_not_receive_identification"
regex = 'Did not receive identification string from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "exploit"

[[services.ssh.patterns]]
name = "connection_reset"
regex = 'Connection reset by (?P<ip>\d+\.\d+\.\d+\.\d+) port \d+ \[preauth\]'
event_type = "failed_auth"

[[services.ssh.patterns]]
name = "bad_protocol_version"
regex = 'Bad protocol version identification.*from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "exploit"

[[services.ssh.patterns]]
name = "ssh_disconnect_protocol_error"
regex = 'Disconnected from (?P<ip>\d+\.\d+\.\d+\.\d+) port \d+.*protocol error'
event_type = "exploit"

[[services.ssh.patterns]]
name = "pam_auth_failure"
regex = 'pam_unix\(sshd:auth\): authentication failure.*rhost=(?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "failed_auth"

[[services.ssh.patterns]]
name = "publickey_not_accepted"
regex = 'Connection closed by authenticating user .* (?P<ip>\d+\.\d+\.\d+\.\d+) .* \[preauth\]'
event_type = "failed_auth"

[[services.ssh.patterns]]
name = "maximum_auth_attempts"
regex = 'error: maximum authentication attempts exceeded for .* from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "brute_force"

[[services.ssh.patterns]]
name = "ssh_banner_exchange"
regex = 'kex_exchange_identification: banner exchange: Connection reset by (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "exploit"

[[services.ssh.patterns]]
name = "ssh_invalid_format"
regex = 'sshd.*error: kex_exchange_identification:.*from (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "exploit"

[services.nginx]
enabled = false
log_path = "/var/log/nginx/error.log"
max_failures = 10
find_time = 60       # 1 minute
ban_time = 600       # 10 minutes

[[services.nginx.patterns]]
name = "limit_req"
regex = 'limiting requests, excess: .* by zone .*, client: (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "rate_limit"

[[services.nginx.patterns]]
name = "limit_conn"
regex = 'limiting connections by zone .*, client: (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "rate_limit"

[[services.nginx.patterns]]
name = "upstream_timeout"
regex = 'upstream timed out.*client: (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "rate_limit"

[[services.nginx.patterns]]
name = "access_forbidden"
regex = 'access forbidden by rule, client: (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "exploit"

[[services.nginx.patterns]]
name = "directory_index_forbidden"
regex = 'directory index of .* is forbidden, client: (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "exploit"

[[services.nginx.patterns]]
name = "client_closed_connection"
regex = 'client prematurely closed connection, client: (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "rate_limit"

# Nginx access log monitoring for web attacks
[services.nginx_access]
enabled = true
log_path = "/var/log/nginx/access.log"
max_failures = 5
find_time = 60
ban_time = 3600

[[services.nginx_access.patterns]]
name = "sql_injection_union"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*(?i)(union\+select|union%20select)'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "sql_injection_or"
regex = "(?P<ip>\\d+\\.\\d+\\.\\d+\\.\\d+).*(?i)(or%201%3D1|or%20'1'%3D'1'|' or ''=')"
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "path_traversal"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*(\.\.\/|\.\.%2f|\.\.%252f)'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "xss_script"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*(<script|%3Cscript|javascript:)'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "cmd_injection"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*(;cat%20|%7Ccat|%60id%60|\$\()'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "wordpress_attack"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*(wp-login\.php|xmlrpc\.php|wp-admin).* 404'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "scanner_uagent"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*"(nikto|sqlmap|nmap|masscan|zgrab|nessus|nuclei)"'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "shell_access"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*(shell\.php|c99\.php|r57\.php|b374k|cmd\.php)'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "sensitive_files"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*(\.env|\.git|\.htaccess|\.htpasswd|wp-config\.php)'
event_type = "exploit"

[[services.nginx_access.patterns]]
name = "admin_bruteforce"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*POST.*(\/admin|\/login|\/wp-login).* 401'
event_type = "brute_force"

[services.apache]
enabled = false
log_path = "/var/log/apache2/error.log"
max_failures = 10
find_time = 60
ban_time = 600

[[services.apache.patterns]]
name = "auth_failure"
regex = 'client (?P<ip>\d+\.\d+\.\d+\.\d+).*authentication failure'
event_type = "failed_auth"

[services.postfix]
enabled = false
log_path = "/var/log/mail.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.postfix.patterns]]
name = "auth_failed"
regex = 'SASL .* authentication failed: .* \[(?P<ip>\d+\.\d+\.\d+\.\d+)\]'
event_type = "failed_auth"

[services.dovecot]
enabled = false
log_path = "/var/log/mail.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.dovecot.patterns]]
name = "auth_failed"
regex = 'auth failed, \d+ attempts .* rip=(?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "failed_auth"

[[services.dovecot.patterns]]
name = "imap_auth_failed"
regex = 'imap-login: Disconnected.*rip=(?P<ip>\d+\.\d+\.\d+\.\d+).*auth failed'
event_type = "failed_auth"

[[services.dovecot.patterns]]
name = "pop3_auth_failed"
regex = 'pop3-login:.*rip=(?P<ip>\d+\.\d+\.\d+\.\d+).*auth failed'
event_type = "failed_auth"

# FTP service monitoring (vsftpd, proftpd)
[services.vsftpd]
enabled = false
log_path = "/var/log/vsftpd.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.vsftpd.patterns]]
name = "ftp_login_failed"
regex = 'FAIL LOGIN: Client "(?P<ip>\d+\.\d+\.\d+\.\d+)"'
event_type = "failed_auth"

[[services.vsftpd.patterns]]
name = "ftp_login_incorrect"
regex = '\[(?P<ip>\d+\.\d+\.\d+\.\d+)\].*LOGIN FAILED'
event_type = "failed_auth"

[services.proftpd]
enabled = false
log_path = "/var/log/proftpd/proftpd.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.proftpd.patterns]]
name = "proftpd_auth_failed"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*USER .+: no such user'
event_type = "invalid_user"

[[services.proftpd.patterns]]
name = "proftpd_pass_failed"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*PASS.*Authentication failed'
event_type = "failed_auth"

# MySQL monitoring
[services.mysql]
enabled = false
log_path = "/var/log/mysql/error.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.mysql.patterns]]
name = "mysql_access_denied"
regex = "Access denied for user.*from '(?P<ip>\\d+\\.\\d+\\.\\d+\\.\\d+)'"
event_type = "failed_auth"

[[services.mysql.patterns]]
name = "mysql_connection_refused"
regex = "Host '(?P<ip>\\d+\\.\\d+\\.\\d+\\.\\d+)' is blocked"
event_type = "brute_force"

# PostgreSQL monitoring
[services.postgresql]
enabled = false
log_path = "/var/log/postgresql/postgresql-main.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.postgresql.patterns]]
name = "pg_auth_failed"
regex = 'FATAL:.*authentication failed for user.*host=(?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "failed_auth"

[[services.postgresql.patterns]]
name = "pg_no_hba"
regex = 'no pg_hba.conf entry for host "(?P<ip>\d+\.\d+\.\d+\.\d+)"'
event_type = "failed_auth"

# Exim mail server
[services.exim]
enabled = false
log_path = "/var/log/exim4/mainlog"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.exim.patterns]]
name = "exim_auth_failed"
regex = 'authenticator failed for .* \[(?P<ip>\d+\.\d+\.\d+\.\d+)\]'
event_type = "failed_auth"

[[services.exim.patterns]]
name = "exim_rejected"
regex = 'rejected connection from \[(?P<ip>\d+\.\d+\.\d+\.\d+)\]'
event_type = "rate_limit"

# Pure-FTPd
[services.pureftpd]
enabled = false
log_path = "/var/log/syslog"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.pureftpd.patterns]]
name = "pureftpd_auth_failed"
regex = 'pure-ftpd: \(\?@(?P<ip>\d+\.\d+\.\d+\.\d+)\) \[WARNING\] Authentication failed'
event_type = "failed_auth"

# Named/BIND DNS
[services.named]
enabled = false
log_path = "/var/log/named/security.log"
max_failures = 10
find_time = 60
ban_time = 600

[[services.named.patterns]]
name = "dns_query_denied"
regex = 'client @.* (?P<ip>\d+\.\d+\.\d+\.\d+)#\d+.*query.*denied'
event_type = "rate_limit"

[[services.named.patterns]]
name = "dns_transfer_denied"
regex = 'client @.* (?P<ip>\d+\.\d+\.\d+\.\d+)#\d+.*zone transfer.*denied'
event_type = "exploit"

# RDP via xrdp
[services.xrdp]
enabled = false
log_path = "/var/log/xrdp-sesman.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.xrdp.patterns]]
name = "xrdp_login_failed"
regex = 'AUTHINFO: authentication failed.*client_ip=(?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "failed_auth"

# OpenVPN
[services.openvpn]
enabled = false
log_path = "/var/log/openvpn.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.openvpn.patterns]]
name = "ovpn_auth_failed"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+):\d+.*AUTH_FAILED'
event_type = "failed_auth"

[[services.openvpn.patterns]]
name = "ovpn_tls_error"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+):\d+.*TLS Error'
event_type = "exploit"

# Asterisk/VoIP
[services.asterisk]
enabled = false
log_path = "/var/log/asterisk/security"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.asterisk.patterns]]
name = "asterisk_failed_auth"
regex = 'SECURITY.*from\s+(?P<ip>\d+\.\d+\.\d+\.\d+).*FailedACL'
event_type = "failed_auth"

[[services.asterisk.patterns]]
name = "asterisk_invalid_pass"
regex = 'SECURITY.*from\s+(?P<ip>\d+\.\d+\.\d+\.\d+).*InvalidPassword'
event_type = "failed_auth"

[[services.asterisk.patterns]]
name = "sip_register_failed"
regex = "SecurityEvent.*RemoteAddress.*IPV4/UDP/(?P<ip>\\d+\\.\\d+\\.\\d+\\.\\d+).*InvalidPassword"
event_type = "brute_force"

# Webmin
[services.webmin]
enabled = false
log_path = "/var/webmin/miniserv.log"
max_failures = 5
find_time = 300
ban_time = 3600

[[services.webmin.patterns]]
name = "webmin_auth_failed"
regex = '(?P<ip>\d+\.\d+\.\d+\.\d+).*Invalid login'
event_type = "failed_auth"

# Recidive - for persistent offenders (scans auth.log for already banned IPs re-attempting)
[services.recidive]
enabled = false
log_path = "/var/log/auth.log"
max_failures = 3
find_time = 86400    # 24 hours
ban_time = 604800    # 1 week

[[services.recidive.patterns]]
name = "repeat_offender"
regex = 'sshd\[\d+\]: Disconnected from banned (?P<ip>\d+\.\d+\.\d+\.\d+)'
event_type = "brute_force"

# ============================================================================
# Port-Based Firewall Rules (UFW-like)
# ============================================================================
# When enabled, all ports are blocked by default.
# You must explicitly allow ports you want to be accessible.
#
# CLI Usage:
#   crmonban port enable                    # Enable port filtering
#   crmonban port disable                   # Disable port filtering
#   crmonban port allow 22/tcp              # Allow SSH
#   crmonban port allow 80/tcp              # Allow HTTP
#   crmonban port allow 443/tcp             # Allow HTTPS
#   crmonban port deny 3306/tcp             # Deny MySQL
#   crmonban port allow 22/tcp --from 192.168.1.0/24  # Allow SSH from LAN
#   crmonban port list                      # List all rules
#   crmonban port status                    # Show status

[port_rules]
# Enable port-based filtering (default deny)
enabled = false

# Default policies (drop, reject, accept)
default_input_policy = "drop"
default_output_policy = "accept"
default_forward_policy = "drop"

# Always allow these (for sanity)
allow_established = true  # Allow established/related connections
allow_loopback = true     # Allow localhost traffic
allow_icmp = true         # Allow ping

# Port rules (applied in priority order, lower = first)
# Each rule has: priority, action, direction, protocol, port, from, to, comment

[[port_rules.rules]]
priority = 100
action = "allow"
direction = "in"
protocol = "tcp"
port = "22"
comment = "Allow SSH"
enabled = true

# Example: Allow HTTP/HTTPS
# [[port_rules.rules]]
# priority = 100
# action = "allow"
# direction = "in"
# protocol = "tcp"
# port = "80"
# comment = "Allow HTTP"
# enabled = true

# [[port_rules.rules]]
# priority = 100
# action = "allow"
# direction = "in"
# protocol = "tcp"
# port = "443"
# comment = "Allow HTTPS"
# enabled = true

# Example: Allow DNS
# [[port_rules.rules]]
# priority = 100
# action = "allow"
# direction = "in"
# protocol = "udp"
# port = "53"
# comment = "Allow DNS"
# enabled = true

# Example: Allow port range
# [[port_rules.rules]]
# priority = 100
# action = "allow"
# direction = "in"
# protocol = "tcp"
# port = "6000-6010"
# comment = "Allow X11 forwarding"
# enabled = true

# Example: Allow from specific network
# [[port_rules.rules]]
# priority = 100
# action = "allow"
# direction = "in"
# protocol = "tcp"
# port = "3306"
# from = "192.168.1.0/24"
# comment = "Allow MySQL from LAN"
# enabled = true

# ============================================================================
# eBPF Malware Detection (Symbiote/BPFDoor Detection)
# ============================================================================
# Detects malicious eBPF programs commonly used by advanced malware:
# - Symbiote: Uses BPF filters for traffic hiding and port-hopping C2
# - BPFDoor: Uses raw socket BPF for covert backdoor communication

[ebpf_malware]
# Enable eBPF malware detection
enabled = false

# Monitor bpf() syscalls for unauthorized program loading
monitor_bpf_syscalls = true

# Monitor raw socket creation with SO_ATTACH_FILTER
monitor_socket_filters = true

# Alert on any BPF program attachment (even whitelisted)
alert_on_attach = true

# Processes allowed to load BPF programs
whitelist_processes = [
    "systemd",
    "dockerd",
    "containerd",
    "cilium",
    "bpftrace",
    "tcpdump",
    "wireshark",
    "crmonban"
]

# Known malicious Symbiote port-hopping ports
known_malicious_ports = [54778, 58870, 59666, 54879, 57987, 64322, 45677, 63227]

# Ban duration for detected malware C2 connections (24 hours)
ban_time = 86400

# ============================================================================
# DNS Covert Channel Detection
# ============================================================================
# Detects DNS-based C2 and data exfiltration channels:
# - High-entropy subdomain queries (encoded data)
# - Oversized TXT record responses
# - Excessive query rates from single source

[dns_monitor]
# Enable DNS monitoring
enabled = false

# Detect potential covert channels in DNS traffic
detect_covert_channels = true

# Maximum allowed DNS query name length (longer may indicate tunneling)
max_query_length = 63

# Minimum entropy threshold (high values indicate encoded/encrypted data)
# Normal domains: ~2.5-3.5, Tunneling: ~4.0+
entropy_threshold = 4.0

# Maximum queries per minute from single IP before flagging
max_queries_per_minute = 100

# Detect TXT record abuse (common for data exfiltration)
detect_txt_abuse = true

# Maximum TXT record response size in bytes
max_txt_response_size = 512

# Ban duration for DNS tunneling (1 hour)
ban_time = 3600

# NFQUEUE number for DNS inspection (must be different from DPI queue)
queue_num = 101

# ============================================================================
# Port Hopping Detection (Symbiote-style)
# ============================================================================
# Detects malware communication patterns that rapidly cycle through
# multiple high ports to evade detection.

[port_hopping]
# Enable port hopping detection
enabled = false

# Number of unique high ports that triggers detection
threshold = 5

# Time window in seconds to count port accesses
window_secs = 30

# Minimum port number to consider (ignore well-known ports)
min_port = 1024

# Ban duration for port hopping detection (2 hours)
ban_time = 7200

# Protocols to monitor
protocols = ["tcp", "udp"]

# ============================================================================
# Packet Engine (NIDS) Configuration
# ============================================================================
# Live packet capture and signature-based detection

[packet_engine]
# Enable packet engine
enabled = true

# Capture method: "af_packet", "nfqueue", or "pcap"
capture_method = "af_packet"

# Interface to capture on
interface = "lo"

# NFQUEUE number (for nfqueue mode)
nfqueue_num = 100

# Enable promiscuous mode
promiscuous = true

# Snapshot length (max bytes per packet)
snaplen = 65535

# Read timeout in milliseconds
timeout_ms = 100

# Number of worker threads (0 = auto-detect)
workers = 0

# Enable signature matching
signatures_enabled = true

# Path to rules directory
rules_dir = "/var/lib/crmonban/data/rules"

# Enable flow tracking
flow_tracking = true

# Enable ML anomaly detection
ml_detection = true

# Enable threat intel lookups
threat_intel = true

# Ban duration for detected attacks (seconds)
ban_duration = 3600

# Auto-ban on signature match
auto_ban = true

# Pipeline stage configuration
[pipeline]
enable_flows = true
enable_scan_detect = true
enable_dos = false
enable_brute_force = false
enable_signatures = false
enable_intel = false
enable_protocols = false
enable_wasm = false
enable_ml = false
enable_correlation = false

# Scan Detection Configuration
[scan_detect]
enabled = true
window_secs = 600

[scan_detect.thresholds]
suspicious = 5.0
probable_scan = 10.0
likely_attack = 15.0
confirmed_scan = 20.0

[scan_detect.weights]
half_open_syn = 5.0
targeted_port_bonus = 2.0
sequential_scan = 8.0
rapid_rate = 6.0
